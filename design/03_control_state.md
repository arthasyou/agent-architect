# 行为调制状态

## Agent 行为调制状态（Control State）设计文档

### 1. 设计目标

行为调制状态的目标不是增加智能，而是**隔离变量**。

> 行为调制状态负责在**不改变认知结论语义**的前提下，
> 对 agent 的行为边界、策略偏好与表达方式
> 进行统一、可控、可切换的调制。

该层的存在，是为了防止：

- 行为需求反向污染认知逻辑
- 岗位差异通过修改 prompt 侵入系统核心
- “风格问题”演化为“系统问题”

---

### 2. 行为调制状态的职责边界

#### 2.1 行为调制状态**负责**

- 定义系统当前允许的行为边界
- 在多种可行方案中提供策略偏好
- 决定认知结果如何被表达、执行或请求确认
- 为行动层提供**非语义性的行为约束**

#### 2.2 行为调制状态**不负责**

- 推理、判断或结论生成（属于认知）
- 长期信息存储（属于记忆）
- 行为具体实现（属于行动）
- 调度与并发管理（属于 Runtime）
- 情绪、人格或角色扮演

---

### 3. 行为调制状态的基本性质

行为调制状态被定义为：

- **显式状态**（而非隐式 prompt）
- **可切换的**（可随场景变化）
- **非语义的**（不改变“想什么”）
- **非记忆性的**（默认不跨长期时间保存）

它描述的是：

> **“在当前系统姿态下，允许如何行动”**

而不是：

> “我是谁”或“我在想什么”。

---

### 4. 行为调制状态的核心作用域

行为调制状态主要作用于以下三个方面：

#### 4.1 行为边界（Constraints）

定义当前系统**允许 / 不允许**的行为类型，例如：

- 是否允许在信息不完整时继续
- 是否允许自动执行
- 是否必须请求用户确认
- 是否允许推测或假设性行动

---

#### 4.2 策略偏好（Policy Bias）

在多个同样合法的方案中，提供选择倾向：

- 保守 vs 探索
- 稳妥 vs 高效
- 简洁 vs 详尽
- 风险最小化 vs 收益最大化

该偏好**不改变认知结果集合**，只影响取舍顺序。

---

#### 4.3 表达与交互方式（Presentation）

决定认知与行动结果如何呈现给外部：

- 是否解释原因
- 是否提示不确定性
- 是否暴露中间判断
- 是否要求确认或反馈

---

### 5. 行为调制状态的输入与输出关系

#### 5.1 输入来源

行为调制状态可以接收：

- 系统初始化配置
- 场景级策略设置
- 用户显式指令（如“谨慎一点”）
- Runtime 提供的执行环境约束

不得直接接收：

- 感官原始信息
- 记忆内容
- 未经认知处理的用户输入

---

#### 5.2 输出去向

行为调制状态的输出主要影响：

- 行动层（行为是否执行、是否需确认）
- 表达层（输出形式）
- 认知调用时的**非语义约束引用**

行为调制状态**不直接驱动行为执行**。

---

### 6. 行为调制状态与认知层的关系

行为调制状态：

- 不向认知层注入新信息
- 不修改认知输入结构
- 只提供**策略与边界引用**

认知层可以在其输出中声明：

- “在当前 Control State 下可行 / 不可行”
- “需要确认 / 可自动执行”

---

### 7. 行为调制状态的典型示例（抽象）

在同一认知结论下，不同行为调制状态可能导致：

- 停止并请求更多信息
- 给出多种方案并提示风险
- 选择最低风险方案直接执行

认知结果保持一致，行为表现发生变化。

---

### 8. 不可变设计原则（Non-Negotiables）

1. 行为调制状态不得改变认知语义
2. 行为风格不得通过 prompt 隐式注入
3. 行为调制状态必须显式、可审计
4. 行为调制状态不得持有长期记忆
5. 行为调制状态不得替代认知决策
6. 行为调制状态只能影响“如何做”，不能影响“想什么”

---

### 9. 设计状态说明

本设计文档为**概念冻结版本**，用于：

- 隔离认知与行为的职责边界
- 支撑多岗位、多场景的行为一致性
- 防止系统演化过程中风格逻辑侵入核心推理

不涉及具体参数、枚举或实现策略。

---

### 10. 定位总结

> **行为调制状态不是智能的一部分，
> 而是智能得以长期保持清晰的前提条件。**
