# 记忆层 Memory

## Agent 记忆层（Memory）设计文档

### 1. 设计目标

记忆层的目标不是“保存历史”，而是**维持长期一致性**。

> 记忆层负责维护一个
> **可被认知层反复利用、修正、弱化与忽略的长期语义背景**，
> 以支持 agent 在长时间尺度上的稳定行为。

记忆 ≠ 日志
记忆 ≠ 数据库
记忆 ≠ 对话记录

---

### 2. 记忆层的职责边界

#### 2.1 记忆层**负责**

- 接收来自认知层的“候选记忆”
- 对记忆进行分类、摘要与状态管理
- 在认知请求下，提供**与当前问题相关的长期背景**
- 支持记忆的弱化、修正与废弃

#### 2.2 记忆层**不负责**

- 决定什么是“正确答案”（属于认知）
- 决定是否执行某个行为（属于行动）
- 影响行为风格或策略（属于控制状态）
- 主动触发回忆（只能被动响应认知请求）
- 维护完整原始历史（非日志系统）

---

### 3. 记忆的基本假设（类脑但非生物）

本项目对“类脑记忆”的理解是**功能层面**的，而非生物实现层面：

- 记忆是**重构式的**，而非原始数据回放
- 记忆是**情境绑定的**，而非孤立事实
- 记忆允许模糊，但追求整体一致
- 忘记是功能，而不是缺陷

---

### 4. 记忆的形成机制（写入侧）

#### 4.1 候选记忆来源

记忆层只接受来自**认知层**的写入请求，常见来源包括：

- 稳定的用户偏好
- 长期目标或约束
- 被多次引用的事实
- 对过往假设的修正结论
- 重要的失败经验或边界条件

> 感官与行动层**不得直接写入记忆**。

---

#### 4.2 写入门槛（Write Gate）

并非所有认知结果都值得进入记忆。

记忆写入必须满足至少一项条件：

- 被多次认知引用
- 明确具有长期价值
- 对未来决策具有约束意义
- 修正了已有记忆内容

一次性、临时性、中间推理结果，默认不进入记忆。

---

#### 4.3 分类与摘要

所有写入的记忆必须经过：

- **语义分类**（偏好 / 事实 / 目标 / 经验 / 约束等）
- **语义摘要**（保留意义，丢弃细节）

记忆层不保证细节精确性，只保证**语义可用性**。

---

### 5. 记忆的生命周期状态

记忆不是静态实体，而是具有生命周期的对象。

每条记忆至少处于以下某一状态之一：

- **候选记忆**：新产生，稳定性低
- **稳定记忆**：多次验证，可长期使用
- **弱化记忆**：长期未被引用，权重下降
- **冲突记忆**：与新认知结果不一致
- **废弃记忆**：明确不再适用，仅供审计

状态变化由**认知层触发**，记忆层负责维护。

---

### 6. 记忆的可质询性（核心特性）

记忆不是事实断言，而是**可被重新解释的假设**。

认知层可以：

- 质疑某条记忆
- 请求修正或弱化
- 标记其不再适用

记忆层不得假定自身内容永远正确。

---

### 7. 记忆的召回机制（读取侧）

#### 7.1 召回触发原则

记忆不会主动输出，只在以下情况下响应：

- 认知层明确请求长期背景
- 当前认知任务需要历史上下文支持

---

#### 7.2 召回视角

记忆召回以**当前认知问题**为中心，而非历史时间轴。

召回依据包括：

- 当前任务类型
- 当前目标或约束
- 当前冲突或不确定点

> 记忆更像“背景提示”，而不是“答案来源”。

---

### 8. 记忆输出形态

记忆层向认知层提供的不是原始记录，而是：

- 与当前问题相关的背景摘要
- 已知的长期偏好或约束
- 潜在冲突或历史修正提示

输出内容：

- 可被认知忽略
- 不直接驱动行为
- 不包含行为风格

---

### 9. 与其他功能模块的关系

- **认知 → 记忆（写）**：提交候选记忆与状态变更
- **记忆 → 认知（读）**：提供相关长期背景
- **感官 / 行动 / 控制状态 / Runtime**：均不得直接访问或修改记忆

记忆层始终通过认知层间接影响系统行为。

---

### 10. 不可变设计原则（Non-Negotiables）

1. 记忆不是完整历史
2. 记忆写入必须有门槛
3. 记忆必须支持弱化与遗忘
4. 记忆必须可被认知层质询
5. 记忆召回以当前问题为中心
6. 记忆不得直接影响行为层

---

### 11. 定位总结

> **让 agent 拥有“过去”，
> 但不被“过去”绑架。**
