## Memory Storage Model

### 1. 目的

本文档定义 **Memory 的存储模型（Storage Model）**，
用于约束 Memory 中允许存储的信息形态，以及明确禁止的存储形式。

该模型的目标是确保：

- Memory 与具体模型实现解耦
- Memory 内容长期可解释、可迁移、可审计
- Memory 不被模型演进、算法变化所污染

---

### 2. 基本原则

#### 2.1 模型无关原则

Memory 中存储的信息 **必须与任何具体模型无关**。

Memory 不应依赖以下任何因素：

- 特定 LLM
- 特定 tokenizer
- 特定 embedding 模型
- 特定向量维度或编码方式

Memory 的内容应在模型完全更换后仍然保持可用与可理解。

---

#### 2.2 可解释原则

Memory 中的每一条记录，必须满足：

- 人类可直接阅读或解析
- 可在无模型参与的情况下被理解
- 可用于调试、审计与回溯

任何不可逆、不可读、不可还原的信息形态，不应作为 Memory 的主存储内容。

---

#### 2.3 不可再生信息优先原则

Memory 只存储 **不可再生的信息**。

如果某类信息满足以下条件之一，则不应作为 Memory 存储内容：

- 可由原始内容重新计算得到
- 可通过确定性过程重新生成
- 仅用于性能优化或检索加速

Memory 是事实载体，而不是缓存或索引。

---

### 3. 允许的存储形态

Memory 允许存储以下信息形态：

#### 3.1 原始文本（Raw Text）

- 人类自然语言文本
- 未经过 tokenization 或 embedding
- 保留原始表达形式

文本是 Memory 中最基础、最稳定的信息形态。

---

#### 3.2 结构化记录（Structured Records）

- 明确字段定义的结构化数据
- key-value、record、JSON 等形式
- 字段语义稳定、与模型无关

结构化数据用于存储状态、配置、标志位等非叙述性信息。

---

#### 3.3 元信息（Metadata）

- 时间戳
- 来源标识
- 记录类型
- 写入上下文标记

元信息用于支持审计与检索，但不参与语义判断。

---

### 4. 明确禁止的存储形态

以下内容 **不得作为 Memory 的主存储内容**：

#### 4.1 Embedding / 向量表示

- 任意维度的向量
- 依赖具体 embedding 模型的表示

原因：

- 强依赖模型实现
- 不可逆
- 无法跨模型迁移
- 语义随模型更新而漂移

---

#### 4.2 Token / Token 序列

- tokenizer 输出结果
- token ID 或 token 流

原因：

- tokenizer 属于模型实现细节
- 不具备稳定的人类语义
- 无法长期保证一致性

---

#### 4.3 派生表示与中间结果

包括但不限于：

- 摘要文本
- 自动归纳结果
- 聚合结论
- 相似度评分
- 排序结果

这些信息属于认知或检索过程的产物，而非事实本身。

---

### 5. Embedding 与索引的正确位置

Embedding、向量索引、检索加速结构：

- 可以存在于系统中
- 可以服务于 Collection 或检索层
- **必须被视为可丢弃、可重建的派生数据**

它们不属于 Memory 的存储模型，也不应作为 Memory 的权威数据来源。

Memory 的权威数据，永远是原始记录。

---

### 6. 演进与兼容性约束

Memory 的存储模型应满足：

- 新模型可以重新解释旧 Memory
- 旧 Memory 不因模型升级而失效
- 不需要迁移历史数据即可更换模型

任何要求“随模型升级同步迁移 Memory 内容”的设计，均违反本模型。

---

### 7. 判定规则（设计自检）

在决定是否将某类数据写入 Memory 时，必须回答：

- 该数据是否人类可读？
- 是否可在无模型条件下理解？
- 是否不可由其他数据重新计算？
- 是否在模型更换后仍然成立？

只要有任一问题答案为否，该数据就不应进入 Memory。

---

### 8. 总结性定义

Memory 的存储模型是：

- 面向长期存在
- 面向人类解释
- 面向模型更替
- 面向事实保存

Memory 存储的是**原始信息材料**，
而不是任何模型视角下的投影结果。
