## Control State · State Model

### 1. 文档目的

State Model 的目的只有一个：

> **穷举 Agent 在时间轴上“可能处在的状态集合”，
> 并为每个状态划定清晰、不可混淆的语义边界。**

本模型不描述状态迁移、不描述触发条件、不描述执行逻辑。

---

### 2. State 的基本原则

在本系统中，一个 Control State 必须满足：

- **互斥性**：任一时刻只能处于一个主状态
- **完备性**：任一合法运行阶段都必须能落入某一状态
- **语义稳定性**：状态含义不随实现变化

状态不是“函数调用阶段”，
而是**系统事实**。

---

### 3. 核心状态集合（最小闭包）

这是建议的**最小且不可再删**的一组状态。

#### 3.1 Idle

**定义**：
系统已就绪，但当前没有被授权处理的任务。

- 不进行推理
- 不产生 Action
- 可被新输入唤醒

Idle 是一切流程的零点。

---

#### 3.2 Collecting

**定义**：
系统正在收集、整理输入信息，但尚未进入认知判断。

- 允许接收外部输入
- 允许 Organize
- 不允许做出决策性结论

这是“事实进入系统”的阶段。

---

#### 3.3 Cognizing

**定义**：
系统正在对当前上下文进行语义理解与推理。

- LLM 推理仅发生于此状态
- 产出为候选判断 / 计划
- 不直接导致执行

这是“理解世界”的唯一合法时段。

---

#### 3.4 Planning

**定义**：
系统正在形成可执行的结构化方案，但尚未执行。

- 允许拆解步骤
- 允许生成多个候选方案
- 不触发外部副作用

Planning 是 **Execution 的前置缓冲区**。

---

#### 3.5 Executing

**定义**：
系统正在执行已被批准的 Action。

- 允许外部副作用
- 不允许修改认知结论
- 行为必须可追踪

这是系统唯一“改变世界”的状态。

---

#### 3.6 Persisting

**定义**：
系统正在将结果写入 Memory 或其他持久介质。

- 不允许产生新 Action
- 不允许再次推理
- 只允许结构化写入

Persisting 是“记忆与历史”的入口。

---

#### 3.7 Suspended

**定义**：
流程被主动或被动中断，但上下文仍然保留。

- 不丢失 Control State
- 可恢复至中断前状态
- 不允许推进流程

这是系统的“安全冻结态”。

---

#### 3.8 Terminated

**定义**：
当前流程被显式结束，不再允许任何推进。

- 不可恢复
- 仅可审计
- 等价于一次生命周期的终点

---

### 4. 明确不属于 State Model 的内容

以下内容**刻意不在本文件中定义**：

- 状态迁移条件
- 谁触发迁移
- 自动 / 手动推进机制
- 并发或嵌套状态

这些内容将由 **Transition Rules** 与 **Authority 文档** 定义。

---

### 5. 设计底线（可以直接原封不动写进去）

> **任何模块都不得假设“自身执行意味着状态推进”。
> 状态推进是 Control State 的显式结果，而非副作用。**
