### Control State 是什么

Control State 是 **Agent 在时间轴上的最小可控状态描述**。

它不关心“为什么这么想”，
只关心：

- 现在在哪一步
- 下一步能不能走
- 这一步是否已经完成
- 是否允许被中断、回滚或覆盖

它是一个**状态机意义上的真源**。

---

### 它不做什么（非常重要）

Control State：

- 不推理
- 不生成内容
- 不解释语义
- 不保存长期记忆

一旦它开始“理解”，系统就会开始发疯。

---

### 它解决的核心问题

没有 Control State，Agent 会出现三种经典病症：

1. **重复执行**
   同一个 action 被多次触发，因为没人声明“这一步已经结束”。

2. **阶段错乱**
   还在 planning，就被允许 execution。

3. **不可审计**
   你永远说不清“系统当时为什么会走到这里”。

Control State 的存在，本质上是：

> 把“流程”从 LLM 手里收回来。

---

### 一个非常干净的抽象

可以把 Control State 看成：

> 一个**纯描述性的状态容器**
>
> 一个**有限但严格的状态迁移规则集**

它回答的问题永远只有一句话：

> **“在当前条件下，系统允许进入的下一种状态是什么？”**
>
> **Control State 不是为了让系统“跑起来”，而是为了让系统“停得住”**。

---

### 前瞻性一点说

后面你会发现：

- Action 是否可执行 → 取决于 Control State
- Memory 是否可写入 → 取决于 Control State
- Runtime 是否允许阻塞 / 并发 → 仍然取决于 Control State

它会变成三者的**交通警察**，而不是老板。
