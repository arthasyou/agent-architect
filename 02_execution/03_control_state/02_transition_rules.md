## Control State · Transition Rules

### 1. 这份文档的思想定位

如果说 State Model 回答的是：

> **“世界上有哪些合法状态”**

那么 Transition Rules 回答的是：

> **“在什么条件下，系统才有资格离开当前状态”**

注意关键词：**资格**，不是“自动发生”。

迁移不是事件结果，而是**被允许的选择**。

---

### 2. Transition 的基本思想约束

在本系统中，状态迁移遵循以下思想原则：

1. **迁移不是必然的**
   满足条件 ≠ 必须迁移，只是“可以被批准”。

2. **迁移不由模块隐式触发**
   任何模块的完成，都只是“候选前提”。

3. **迁移是一次显式评估的结果**
   系统必须“回头看一眼”，再决定是否继续。

换句话说：
**流程不是流水线，而是关卡制。**

---

### 3. Transition Rules 在思想上的作用

Transition Rules 的真正功能不是“推进流程”，
而是**阻止错误推进**。

它存在的首要价值是回答：

- 为什么现在**不能**进入下一状态
- 为什么这里**必须停一下**
- 为什么这一步**需要人工或外部介入**

---

### 4. 迁移规则的三种思想前提

任何合法迁移，都必须同时满足三类前提（思想层面）：

#### 4.1 状态前提（State Preconditions）

- 当前状态是否允许离开
- 是否存在“不可中断”的语义约束

例子（思想，不是规则）：

> Executing 状态下，系统不应被轻易推进到 Cognizing。

---

#### 4.2 完整性前提（Completion Preconditions）

- 当前状态的“本质目标”是否已经完成
- 是否仍存在未处理的必要产物

这里强调的是：
**状态的意义是否已经被兑现**。

---

#### 4.3 安全前提（Safety Preconditions）

- 推进是否会导致不可逆后果
- 是否存在未确认的风险

这是 Transition Rules 与“工程理性”相连的地方。

---

### 5. 核心迁移范畴（思想级，不是流程图）

下面描述的是**允许被考虑的迁移范畴**，而不是顺序。

---

#### Idle → Collecting

**思想条件**：
系统被明确授权进入一次新的处理生命周期。

关键点不是“有输入”，
而是**输入被承认为一次任务的起点**。

---

#### Collecting → Cognizing

**思想条件**：
当前信息已达到“可被理解”的最低完整度。

不是信息多，而是**信息闭合**。

---

#### Cognizing → Planning

**思想条件**：
系统已经形成至少一个可被表达的判断或结论。

如果系统“还在想”，就不该离开 Cognizing。

---

#### Planning → Executing

**思想条件**：
存在一个被明确批准的执行方案。

注意：

> “有计划” ≠ “允许执行”

---

#### Executing → Persisting

**思想条件**：
外部行为已完成，且其结果需要被固化。

如果没有“值得记住的结果”，不必强行 Persist。

---

#### Persisting → Idle

**思想条件**：
本次生命周期的信息已完成归档，
系统不再携带未处理的时间负担。

---

#### 任意状态 → Suspended

**思想条件**：
继续推进将带来不确定或不可接受的风险。

Suspended 是一种**理性选择**，不是异常。

---

#### Suspended → 原状态

**思想条件**：
中断原因已被解除，
且上下文仍然有效。

---

#### 任意状态 → Terminated

**思想条件**：
系统明确放弃继续该生命周期。

这是**终止权**，不是失败路径。

---

### 6. 一个极其重要的否定性原则

Transition Rules 中最重要的不是“允许什么”，
而是下面这句话：

> **任何状态迁移，
> 都不应仅因为“上一步完成了”。**

这是所有隐性 bug 的源头。

---

### 7. Transition Rules 的思想底线

> **状态迁移不是流程推进机制，
> 而是系统对“是否继续前进”的一次自我审查。**
