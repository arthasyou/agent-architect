## Memory IO

### 0. 目的

Memory IO 定义 Memory 系统对外暴露的**唯一交互契约**。
该契约必须同时满足：

- **无语义**：不引入相关性/重要性判断能力
- **可审计**：每次读写都有明确来源与边界
- **可演化**：不绑定模型实现与存储实现
- **最小化**：避免把 Memory 变成半个查询引擎

---

## 1. Write IO

### WriteRequest

```
MemoryWriteRequest {
  record: MemoryRecord
  source: WriteSource
  request_id: RequestId
}
```

**约束：**

- `record` 必须符合 Memory Record Model 定义的合法 Record（FACT/EVENT/STATE 之一）。
- `request_id` 用于幂等与审计；IO 层不解释其语义，只保证“原样回传/记录”。
- `source` 必须可追溯，且不携带语义判断结果（例如“重要性”“是否重复”）。

### WriteSource

```
WriteSource {
  agent_id: AgentId
  component: SourceComponent
  actor: SourceActor
}
```

```
SourceComponent =
  | COGNITION
  | MAINTENANCE
```

```
SourceActor =
  | SYSTEM
  | USER
  | EXTERNAL
```

**约束：**

- `component` 表示**谁发起写入**（系统内部模块归属），用于权限与审计。
- `actor` 表示**是谁导致该写入发生**（人/系统/外部输入），用于追溯，不用于决策。
- `agent_id` 强制绑定 Agent 私有性：写入必须归属某个 agent 的 memory 域。
- 正常运行中只允许 `COGNITION` 发起写入；`MAINTENANCE` 仅用于离线迁移或人工维护流程。

> 解释到此为止：WriteSource 只用于“追溯与隔离”，不引入任何“价值判断”。

### WriteResult

```
MemoryWriteResult =
  | ACCEPTED { stored_id: RecordId }
  | REJECTED
```

**约束：**

- 结果必须是二值：接受或拒绝。
- `stored_id` 仅在 ACCEPTED 时存在，用于后续引用与审计。
- 不返回拒绝原因码（原因属于实现细节/策略层，避免 IO 被策略污染）。

---

## 2. Read IO

### ReadRequest

```
MemoryReadRequest {
  record_type: RecordType
  selector: ReadSelector
  request_id: RequestId
}
```

**约束：**

- `record_type` 必须显式指定（FACT/EVENT/STATE），防止“跨类型混查”导致语义漂移。
- `selector` 必须是**有限集合**，禁止任意查询语言。
- `request_id` 同 Write，用于审计与追踪。
- Read 只能由 Collection 发起；其他模块不得直接读取 Memory。

### ReadSelector

```
ReadSelector =
  | ById { id: RecordId }
  | ByKey { key: FactKey }                 // 仅适用于 FACT
  | ByTimeRange { from: Timestamp, to: Timestamp, limit: Int }   // 仅适用于 EVENT/STATE
  | Latest { limit: Int }                  // 仅适用于 STATE/EVENT（语义由调用方定义）
  | Limit { limit: Int }                   // 仅用于截断结果集
```

**约束：**

- selector 不表达“相关性/相似度”，只表达**显式边界**（id/key/time/limit）。
- ByKey 的 key 必须是规范化后的 FactKey（禁止自由文本 key）。
- ByTimeRange 必须携带 `limit`，保证读取天然有界。

### ReadResult

```
MemoryReadResult {
  records: MemoryRecord[]
}
```

**约束：**

- `records` 可以为空。
- 返回顺序必须可定义且稳定：

  - EVENT：按时间戳升序或降序（固定一种，文档需统一）
  - STATE：按时间戳降序（最新优先）
  - FACT：顺序不承诺（或按 key 排序，但不要引入语义）

（这里的“顺序稳定”属于骨架契约，不是实现细节。）

---

## 3. Core Types

### RecordType

```
RecordType =
  | FACT
  | EVENT
  | STATE
```

### Identifiers

```
RecordId = string
RequestId = string
AgentId = string
Timestamp = int64
FactKey = string
```

---

## 4. Structural Guarantees

- Write 不保证成功（REJECTED 为正常控制流）
- Read 不保证非空
- IO 不返回派生信息（摘要、相似度、评分等）
- IO 不暴露存储细节（索引、分页实现、数据库字段等）
- IO 不提供通用查询语言（防止 Memory 被滥用为检索引擎）

---

### 5. Why This Shape

- **显式 record_type + 有限 selector**：把“可见性”锁在规则里，避免语义检索滑坡。
- **WriteSource 最小化但可追溯**：让审计与隔离成立，但不引入“是否值得记住”的判断字段。
- **二值写入结果**：阻断 IO 层承载策略空间（例如原因码、修复建议），防止边界被侵蚀。
- **所有读取天然有界（limit）**：保证“有限可见性”在 IO 层即可被证明。
