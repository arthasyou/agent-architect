# Action（行动）模块设计文档

## 1. 模块定位

**Action 是 Agent 的执行层，等价于人的手和脚。**

Action 不进行思考、不做判断、不理解语义，
只负责将 **已完成的决策** 转化为对外部世界的 **真实、副作用性的执行行为**。

在 Agent 的整体架构中，Action 是**唯一允许产生副作用的模块**。

---

## 2. 核心原则

### 2.1 不参与认知

Action 不解释指令的意图，也不判断其合理性。
所有“该不该做”的问题，必须在 Cognition 阶段完成。

### 2.2 不对结果负责

执行的成功、失败、异常、超时，
都只是 **客观事实**，而非 Action 的结论。

这些结果的意义，由后续 Cognition 处理。

### 2.3 不包含策略

Action 不包含：

- 重试逻辑
- 回滚机制
- 条件分支决策
- 工具择优
- 自适应行为

任何策略性行为，均属于认知范畴。

### 2.4 只保证因果发生

Action 的唯一职责是：

> **尝试执行指令，并如实返回执行结果**

---

## 3. 职责边界

### 3.1 Action 负责

- 接收结构化的 Action 指令
- 选择**已指定**的执行通道
- 执行产生真实副作用的操作
- 返回完整、未解释的执行结果

### 3.2 Action 不负责

- 决策
- 规划
- 错误分析
- 行为修正
- 状态推断
- 成功与否的价值判断

---

## 4. Action 在 Agent 中的位置

Agent 的基本执行闭环为：

```
Perception → Cognition → Action → Perception
```

- Perception：世界 → 信息
- Cognition：信息 → 决策
- Action：决策 → 世界

Action 不形成内部闭环，
也不尝试“修正世界”。

---

## 5. Action 的抽象模型

### 5.1 通用 Action 抽象

Action 在架构层面被定义为一个 **trait / interface**，
描述的是 **执行协议**，而不是具体能力。

该抽象定义：

- 输入的结构约定
- 执行的生命周期
- 输出结果的表达形式

而不关心底层执行方式。

---

### 5.2 通用 Action 与具体实现的分离

- **通用 Action**

  - 定义“如何执行”
  - 保持稳定、最小、不可膨胀
  - 不绑定具体环境或技术

- **具体 Action 实现**

  - 由不同开发者按需实现
  - 面向不同执行环境或能力来源
  - 以插件或模块形式接入系统

这种分离确保：

- Action 能持续扩展
- 核心架构不被能力细节污染
- 多人协作不会破坏系统边界

---

## 6. 已明确的 Action 类型（当前）

目前已讨论并明确的 Action 实现包括：

### 6.1 本地执行类 Action

- 系统命令执行
- 文件系统操作
- 进程与资源控制

这类 Action 直接作用于宿主运行环境。

### 6.2 外部能力调用类 Action

- MCP Server 调用
- 远程服务执行
- 能力代理接口

这类 Action 将指令映射为外部系统的执行请求。

---

## 7. 面向未来的开放性

Action **不枚举所有可能的执行类型**。

任何满足以下条件的模块，都可以作为一个 Action 实现：

- 接收结构化指令
- 产生真实副作用
- 返回未解释的执行事实
- 不引入认知或策略逻辑

因此，未来可能出现的 Action 包括但不限于：

- 硬件与设备控制
- UI / 自动化操作
- 网络与消息系统交互
- 特定领域执行器（如游戏、仿真、设备）

这些扩展：

- 不需要修改 Cognition
- 不应反向影响 Action 抽象定义

---

## 8. 核心共识（一句话）

> **Action 是副作用的出口，不是智能的一部分。**

它越简单，Agent 越清醒；
它越愚蠢，系统越可靠。
