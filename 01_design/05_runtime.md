# 调度层

## Agent 时间 / 调度层（Runtime）设计文档

### 1. 设计目标

Runtime 的目标是**可控的时间序列**，而不是吞吐量。

> Runtime 负责以**单线程（Single-Thread）**方式驱动 agent 的认知与行动，
> 在外界事件与用户指令打断时，提供**中断、挂起与恢复**机制，
> 使 agent 像人一样“一次只专注一件事”，但不会丢失上下文。

---

### 2. Runtime 的职责边界

#### 2.1 Runtime 负责

- 维护“当前焦点任务”（Focus Task）
- 管理任务队列（Backlog）与当前执行序列
- 支持中断（Interrupt）、挂起（Suspend）与恢复（Resume）
- 管理等待（Wait）与超时（Timeout）
- 将运行态变化反馈给认知层

#### 2.2 Runtime 不负责

- 推理与决策（认知层）
- 行为策略偏好（控制状态）
- 具体执行（行动层）
- 长期保存（记忆层）
- 信息采集解释（感官层）

> Runtime 只决定：**现在做哪一件事**，以及**被打断后如何回来**。

---

### 3. 核心假设

1. **单线程执行**：同一时刻只能有一个任务处于 Running
2. **允许插队**：高优先级事件可中断当前任务
3. **可恢复**：被中断的任务必须能在未来恢复（在安全点）
4. **外界不可靠**：行动可能失败、等待可能超时、环境可能变化

---

### 4. Runtime 管理的对象

#### 4.1 任务（Task）

Runtime 的调度单元是任务，而不是模块。任务可能包含：

- 一次认知（Cognition cycle）
- 一次或多次行动步骤（Action steps）
- 等待外部响应（Waiting）

#### 4.2 任务上下文（Task Context）

为了可恢复，任务必须携带最小上下文，例如：

- 当前阶段/步骤指针（Step / Phase）
- 已完成的行动结果摘要（由认知提供或确认）
- 继续执行所需的前置条件（Preconditions）
- 等待的外部事件标识（Wait handle）

> 关键点：Runtime 不“理解”上下文内容，只负责保存与回传。

---

### 5. 运行模型：注意力栈 + 待办队列

Runtime 维护两类结构：

1. **焦点栈（Focus Stack）**

   - 顶部是当前正在做的任务
   - 被中断的任务压栈（Suspend）
   - 恢复时弹栈（Resume）

2. **待办队列（Backlog Queue）**

   - 非紧急任务排队等待成为焦点
   - 队列顺序由显式优先级/时间等规则决定（规则由 Runtime 执行，不推理）

这对应人的体验：

- 被打断 → 把手头事“放一边”
- 处理更急的事 → 完了再回来续上

---

### 6. 状态机（单线程版本）

每个任务至少具备以下状态：

- Created（创建）
- Ready（可运行）
- Running（运行中）
- Waiting（等待外部事件）
- Suspended（被中断挂起）
- Completed（完成）
- Failed（失败）
- Cancelled（取消）

#### 6.1 允许的关键转换

- Running → Suspended（被中断）
- Suspended → Ready（可恢复）
- Ready → Running（成为焦点）
- Running → Waiting（等待）
- Waiting → Ready（事件到达或超时返回）
- Running → Completed / Failed

---

### 7. 中断与恢复（核心机制）

#### 7.1 中断（Interrupt）

中断只能在**安全点（Safe Point）**发生。安全点由行动层/认知层通过“可中断标记”声明，Runtime 只执行。

中断发生时 Runtime 必须：

- 记录当前任务上下文（最小可恢复信息）
- 将其置为 Suspended 并压入 Focus Stack
- 选择新的焦点任务进入 Running

#### 7.2 恢复（Resume）

恢复条件可能包括：

- 无更高优先级任务
- 当前控制状态允许继续
- 前置条件仍成立（由认知层判断，Runtime 不判断）

恢复时 Runtime：

- 将任务从 Suspended 置为 Ready
- 在合适时机切换为 Running
- 将其上下文交还给认知层进行“续写式再认知”

> 重要：恢复不是“从原地继续执行代码”，而是“带着上下文重新进入一次认知”。

---

### 8. 等待与超时

#### 8.1 等待（Waiting）

行动层可能触发等待（例如外部系统返回、用户确认、设备响应）。Runtime 负责：

- 进入 Waiting
- 监听/轮询事件到达（机制不在定义层讨论）
- 事件到达后转为 Ready

#### 8.2 超时（Timeout）

任何 Waiting 都必须有超时策略：

- 超时 → 回到 Ready，并附带“超时事实”给认知层
- 是否重试、是否放弃，由认知在控制状态约束下决定

---

### 9. 与模块关系（按你的系统约束重述）

- **认知 ↔ Runtime**：Runtime 提供“当前任务上下文/状态”；认知提供“下一步动作/是否可中断/是否完成”
- **行动 ↔ Runtime**：Runtime 调用行动；行动返回事实结果/可中断点/等待句柄
- **控制状态 → Runtime**：提供是否允许自动继续、是否必须确认、是否允许打断等约束
- **感官 → Runtime**：感官事件可触发中断请求（是否插队由 Runtime 执行规则决定）
- **记忆**：不直接参与调度，只通过认知参与“恢复时的再对齐”

---

### 10. 不可变设计原则（Non-Negotiables）

1. **单线程**：同一时刻只有一个 Running 任务
2. **可中断**：中断优先于一次性完成
3. **可恢复**：挂起任务必须能带上下文回来
4. **无推理**：Runtime 不判断对错与策略
5. **超时必有**：等待不可无限期
6. **事实回传**：行动结果与中断/超时必须可审计

---

### 11. 一句话定位总结

> **Runtime 是注意力与任务切换系统：
> 一次只做一件事，但随时能被打断，并且能回来把事做完。**
