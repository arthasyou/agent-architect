# Agent State · Formation & Evolution

## 1. 文档目的

本文件用于说明 **Agent State 如何形成与变化**。

它回答的问题不是：

> 谁来“控制”或“切换” State

而是：

> **Agent State 作为系统事实，
> 是如何在运行过程中自然形成与演化的。**

本文件不引入新的控制机制，
也不赋予任何模块对 State 的主导权。

---

## 2. 基本立场（必须先明确）

Agent State **不存在“控制者”**。

它不是：

- 被某个模块显式设置的值
- 被流程推进触发的阶段标记
- 被指令切换的运行模式

Agent State 描述的是：

> **在当前时刻，
> Agent 所处的整体运行条件是否成立。**

就像人体状态一样：

- 没有人“切换”为疲劳
- 也没有器官“控制”专注状态
- 状态是由整体运行事实共同决定的

---

## 3. State 的形成方式

Agent State 是一种 **派生状态（derived state）**。

它并非被直接写入，
而是从系统运行中的多个事实中**综合形成**。

这些事实可能包括（示意性）：

- 资源占用与系统负载
- 近期认知活动的强度
- 正在执行或等待的 Action 数量
- 外部输入的密度与节奏
- Runtime 的拥塞或延迟情况

State 的每一个维度，
都应当能够被理解为：

> **对当前系统现实的一种抽象描述**，
> 而不是一次命令的结果。

---

## 4. State 的变化方式

Agent State 的变化具有以下特征：

- **渐进的**：不是瞬时跳变
- **连续的**：不是离散切换
- **可叠加的**：多个维度可同时变化
- **无事件边界的**：不依赖“进入 / 退出”事件

State 的变化可能发生在：

- 任务执行过程中
- 多个 Action 并发时
- 长时间空闲或等待期间
- 外部环境节奏改变时

这些变化不构成流程推进，
也不意味着系统进入某个新阶段。

---

## 5. 谁“影响”了 State（而非谁控制）

虽然 State 没有控制者，
但系统中的多个部分都会**对 State 的形成产生影响**。

例如（语义层面）：

- Cognition 的持续高强度运行
  → 影响认知负载相关的 State 维度
- Runtime 的调度压力
  → 影响系统压力与拥塞相关维度
- Action 的执行密度与副作用
  → 影响执行保守性相关维度

这些影响是：

- 间接的
- 非指令式的
- 不可单点主导的

没有任何模块可以**单方面声明**：

> “State 现在必须是 X”。

---

## 6. State 与模块行为的因果方向

必须严格保持以下因果关系方向：

```
系统运行事实
    ↓
Agent State（整体状态）
    ↓
模块在运行时参考 State
```

而不是：

```
模块想做什么
    ↓
修改 State
    ↓
State 反过来允许行为
```

后一种结构将使 State 退化为控制器，
这是明确禁止的。

---

## 7. 明确禁止的模式（强约束）

以下设计在语义上是**不允许的**：

- 某模块显式 set / switch State
- 用 State 表示“现在允许做什么”
- 用 State 作为流程前置条件
- 用 State 作为授权或锁机制

如果某个 State 变化必须由某模块“批准”，
那它已经不是 State，而是控制逻辑。

---

## 8. 设计目标回收

Agent State 的形成与演化设计目标是：

> **让 State 成为对系统现实的忠实描述，
> 而不是系统行为的指挥者。**

它像人体状态一样：

- 无人主控
- 自然形成
- 持续变化
- 被各系统部分同时感知

---

## 9. 小结

- Agent State **没有控制者**
- State 不是被切换的，而是被观察到的
- State 的变化源于系统整体运行事实
- 模块只能影响 State 的形成，不能主导它

只要这一点不被破坏，
Agent State 就永远不会退化成一个隐形控制系统。
